// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../gen-cpp/proxy.h"
#include "../gen-cpp/LRUCache.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <stdio.h>
#include <memory>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <curl/curl.h>
#include <signal.h>

struct wd_in {
  size_t size;
  size_t len;
  char *data;
};

/* This function is registered as a callback with CURL.  As the data
   from the requested webpage is returned in chunks, write_data is
   called with each chunk.  */
static size_t write_data(void *buffer, size_t size,
                         size_t nmemb, void *userp) {
  struct wd_in *wdi = (struct wd_in*)userp;

  while(wdi->len + (size * nmemb) >= wdi->size) {
    /* check for realloc failing in real code. */
    wdi->data = (char*)realloc(wdi->data, wdi->size*2);
    wdi->size*=2;
  }

  memcpy(wdi->data + wdi->len, buffer, size * nmemb);
  wdi->len+=size*nmemb;

  return size * nmemb;
}


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::proxy;

int total_req = 0;
int hits =0;
long cache_size = 65536;
void handler(int SIGNUM){
	printf("Hit ratio: %3.2f\n",hits*100/float(total_req));
	exit(EXIT_SUCCESS);
}

class proxyHandler : virtual public proxyIf {
 private:
	LRUCache* cache;
 public:
  proxyHandler() {
	printf("Proxy server started...\n");
	printf("Instantiating LRUCache...\n");
	cache = new LRUCache(cache_size);
	printf("LRUCache instantiated...\n");
  }
  virtual ~proxyHandler() {
      delete cache;
      printf("LRUCache deallocated...\n");
  }

  void fetch_page(std::string& _return, const std::string& url) {
    // Your implementation goes here
    printf("fetch_page %s...\n",url.c_str());
	total_req+=1;
	if (cache->contains(url)) { // if url already in cache
    	    printf("cache contains %s\n", url.c_str());
		hits+=1;
	    _return = cache->get(url);
	    printf("size of data for key %s is %lu byte\n", url.c_str(), _return.size());
	    printf("Current recent element is %s\n", cache->getRecent().c_str());
	    printf("Current old element is %s\n", cache->getOld().c_str());
	    return;
        }

	printf("cache does not contain %s\n", url.c_str());
	
	CURL *curl;
	CURLcode res;
	struct wd_in wdi;

	memset(&wdi, 0, sizeof(wdi));

	/* Get a curl handle.  Each thread will need a unique handle. */
	curl = curl_easy_init();

	if(NULL != curl) {
		wdi.size = 1024;
		/* Check for malloc failure in real code. */
    	wdi.data = (char*)malloc(wdi.size);

    	/* Set the URL for the operation. */
    	curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

    	/* "write_data" function to call with returned data. */
    	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);

    	/* userp parameter passed to write_data. */
    	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);

    	/* Actually perform the query. */
    	res = curl_easy_perform(curl);

    	/* Check the return value and do whatever. */
		if(res < 0){
			fprintf(stderr,"Error in CURL GET!\n");
			exit(EXIT_FAILURE);
		}
    	/* Clean up after ourselves. */
    	curl_easy_cleanup(curl);
	}else{
    	fprintf(stderr,"Error! Could not get CURL handle!\n");
		exit(EXIT_FAILURE);	
	}

	/* Return the data */
	_return = std::string(wdi.data);
        printf("size of data for key %s is %lu byte\n", url.c_str(), _return.size());
	// add url and data into cache
	std::string key = url;
        std::string data = _return;
        cache->put(key,data);
	printf("Current size is %lu byte\n", cache->getSize());
	printf("Current recent element is %s\n", cache->getRecent().c_str());
	printf("Current old element is %s\n", cache->getOld().c_str());

	/*Free the original buffer */
	free(wdi.data);
  }
};

int main(int argc, char **argv) {
  int port = 9090;
  signal(SIGINT, handler);
  cache_size = atol(argv[1]);
  shared_ptr<proxyHandler> handler(new proxyHandler());
  shared_ptr<TProcessor> processor(new proxyProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

