// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../gen-cpp/proxy.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <curl/curl.h>
#include <map>
#include <signal.h>

struct wd_in {
  size_t size;
  size_t len;
  char *data;
};

/* This function is registered as a callback with CURL.  As the data
   from the requested webpage is returned in chunks, write_data is
   called with each chunk.  */
static size_t write_data(void *buffer, size_t size,
                         size_t nmemb, void *userp) {
  struct wd_in *wdi = (struct wd_in*)userp;

  while(wdi->len + (size * nmemb) >= wdi->size) {
    /* check for realloc failing in real code. */
    wdi->data = (char*)realloc(wdi->data, wdi->size*2);
    wdi->size*=2;
  }

  memcpy(wdi->data + wdi->len, buffer, size * nmemb);
  wdi->len+=size*nmemb;

  return size * nmemb;
}

CURL *curl;
CURLcode res;
struct wd_in wdi;

void fetch(std::string url){

	memset(&wdi, 0, sizeof(wdi));

	/* Get a curl handle.  Each thread will need a unique handle. */
	curl = curl_easy_init();

	if(NULL != curl) {
		wdi.size = 1024;
		/* Check for malloc failure in real code. */
    	wdi.data = (char*)malloc(wdi.size);

    	/* Set the URL for the operation. */
    	curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

    	/* "write_data" function to call with returned data. */
    	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);

    	/* userp parameter passed to write_data. */
    	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);

    	/* Actually perform the query. */
    	res = curl_easy_perform(curl);

    	/* Check the return value and do whatever. */
		if(res < 0){
			fprintf(stderr,"Error in CURL GET!\n");
			exit(EXIT_FAILURE);
		}
    	/* Clean up after ourselves. */
    	curl_easy_cleanup(curl);
	}else{
    	fprintf(stderr,"Error! Could not get CURL handle!\n");
		exit(EXIT_FAILURE);	
	}
}

/* Node structure for proxy FIFO queue */
typedef struct node_s{
	char* url;
	long url_size;
	struct node_s *next;
}node_t;

/* performance metrics variables */
long total_requests =0;
long hits =0;

/* Global data for proxy cache */
long cache_size = 256*1024; //size in KBs
long available_cache_size = cache_size;
std::map<std::string,std::string> proxy_cache;
std::string url_body;
char* urls[100];
long url_sizes[100];
int cache_length =0;
std::string policy = "fifo";

void signal_handler(int signum){
	printf("\nProxy Web server hit rate: %3.2f%"
			"\n",hits*100/float(total_requests));
	exit(EXIT_SUCCESS);
}

int in_cache(std::string url){
	return (proxy_cache.find(url) != proxy_cache.end());
}

std::string get_url(std::string url){
	return proxy_cache.find(url)->second;
}

int make_space(long size){
	int i,random;
	if(size <= cache_size){
		if (policy == "fifo"){
			while (size > available_cache_size){
				proxy_cache.erase(urls[0]);
				available_cache_size += url_sizes[0];
				//Update the URL list and size
				for(i=0;i<cache_length-1;i++){
					urls[i] = urls[i+1];
					url_sizes[i] = url_sizes[i+1];
				}
				cache_length -= 1;
			}
		}
	
		else if(policy == "random"){
			while (size > available_cache_size){
				if(cache_length == 0){
					fprintf(stderr,"Logic error!\n");
					exit(EXIT_FAILURE);
				}
				random = rand() % cache_length;
				fprintf(stderr,"Erasing %s\n",urls[random]);
				proxy_cache.erase(urls[random]);
				available_cache_size += url_sizes[random];
				//Update the URL list and size
				for(i=random;i<cache_length-1;i++){
					urls[i] = urls[i+1];
					url_sizes[i] = url_sizes[i+1];
				}
				cache_length -= 1;
			}
		}
		
		else{
			fprintf(stderr,"Error...Unknown policy!\n");
			exit(EXIT_FAILURE);
		}
		return (size <= available_cache_size);
	}
	else{
		fprintf(stderr,"\tEntry too big to fit in cache!\n");
		return(size <= cache_size); 
	}
}

void insert_url(std::string url, long size){
	/* add entry to the hashmap */
	proxy_cache.insert(std::pair<std::string,std::string>(url,url_body));
	/* Update the list of urls in cache and the list of its sizes */
	urls[cache_length] = (char *)url.c_str();
	url_sizes[cache_length] = size;
	
	available_cache_size -= size;
	cache_length += 1;
}

void print_cache(){
	int i;
	fprintf(stderr,"\tCache length: %d\n",cache_length);
	fprintf(stderr,"\tAVAILABLE SIZE: %3.2fKB\n",available_cache_size/(float)1024);
	fprintf(stderr,"\tThe queue is:\n");
	for (i=0;i<cache_length;i++){
		fprintf(stderr,"\t\tURL: %s size: %3.2fKB\n",\
				urls[i],url_sizes[i]/(float)1024);
	}
}

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::proxy;

class proxyHandler : virtual public proxyIf {
 public:
  proxyHandler() {
	printf("Proxy server started...\n");
  }

  void fetch_page(std::string& _return, const std::string& url) {
    // Your implementation goes here
    printf("fetch_page %s...\n",url.c_str());
	total_requests += 1;
	/* Check if the entry is in cache */
	if (in_cache(url)){
		hits += 1;
		fprintf(stderr,"\tEntry found in proxy cache\n");
		print_cache();
		_return = get_url(url);
		return;
	}
	else{
		fetch(url);
		url_body = std::string(wdi.data);
		long url_size = url_body.length();
		// Check space for the new entry
		if(make_space(url_size)){
			//insert new entry in cache
			insert_url(url,url_size);
			fprintf(stderr,"\tEntry inserted into cache\n");
		}
		print_cache();
		/* Return the data */
		//_return = std::string(wdi.data);
		_return = url_body;
		/*Free the original buffer */
		free(wdi.data);
	}	
  }
};

void usage(){
	fprintf(stderr,"Usage: ./proxyserver <cache_size> <replacement_policy>"\
			"\ncache_size: size of the proxy cache in KB"\
			"\nreplacement_policy: fifo or random\n");
}

int main(int argc, char **argv) {
  int port = 9090;
  signal(SIGINT, signal_handler);
 
  if (argc != 3)
	usage();  
  cache_size = atol(argv[1])*1024; //cache size in KBs
  available_cache_size = cache_size;
  policy = std::string(argv[2]);

  shared_ptr<proxyHandler> handler(new proxyHandler());
  shared_ptr<TProcessor> processor(new proxyProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

